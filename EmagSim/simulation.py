from components import *
from dataclasses import dataclass
import numpy as np

"""
TODO:
Clean up the transmit method for transmission lines and add fanout capability
Add in the json capability
Design the gui and allow it to change values through passing data
Reset method
phaser implementation

long term add in a rk4 simulation
"""

@dataclass
class ComponentWrapper:
    component: Component
    x: np.ndarray
    y: np.ndarray

@dataclass
class TLineData:
    x: np.ndarray
    y: np.ndarray
    voltage_V: np.ndarray
    current_A:np.ndarray

class Simulation:
    """
    A base class to define the functionality of a simulation
    """

    # A list of the components in this simulation connected with their 3d mapping for easy graphing
    components: ComponentWrapper = None

    def __init__(self, delta_t_S):
        self.sim_info = SimInfo(0, delta_t_S)

    def step(self):
        self.components: ComponentWrapper
        """Steps the simulation by 1 time step"""
        # Run the transmission part of the simulation
        for wrapped in self.components:
            component: Component = wrapped.component
            component.run_transmissions()

        # Run the update part of the simulation
        for wrapped in self.components:
            component: Component = wrapped.component
            component.update_component()

        # Update the sim info
        self.sim_info.timeStep += 1

    def get_data(self) -> list[TLineData]:
        """Returns the data from the simulation will be the x, y and the tline data"""
        tline_datas: list[TLineData] = []
        for wrapped in self.components:
            component: Component = wrapped.component
            if isinstance(component, TransmissionLine):
                voltage = component._f_voltage_V + component._b_voltage_V
                current = voltage / component.impedance_ohms
                data = TLineData(wrapped.x, wrapped.y, voltage, current)
                tline_datas.append(data)
        return tline_datas
    

# Defining example simulations
# TODO Eventually want to have these defined in a json or yaml and autogenerated as the connection algebra can be quite tedious and confusing


class TlineSim(Simulation):
    """A sample simulation for a simple t-line and source connected to a load"""

    def __init__(self):
        super().__init__(1)

        source = VoltageSource(50, self.sim_info, 3)
        tline = TransmissionLine(100, self.sim_info, 60)
        load = ResistiveLoad(100000, self.sim_info)

        source.connect(ConnectionType.CASCADE, Connection(tline, lambda value: tline.receive_transmission(TlinePorts.FRONT, value)))
        tline.connect(
            (ConnectionType.CASCADE, ConnectionType.CASCADE),
            Connection(load, load.receive_transmission),
            Connection(source, source.receive_transmission)
        )

        source_wrapped = ComponentWrapper(source, None, None)
        tline_wrapped = ComponentWrapper(tline, np.linspace(0, 60, 60), np.zeros(60))
        load1_wrapped = ComponentWrapper(load, None, None)

        self.components = [source_wrapped, tline_wrapped, load1_wrapped]


class CascadeSim(Simulation):

    def __init__(self):
        super().__init__(1)

        source = VoltageSource(50, self.sim_info, 3)
        tline1 = TransmissionLine(100, self.sim_info, 60)
        tline2 = TransmissionLine(50, self.sim_info, 60)
        load = ResistiveLoad(100000, self.sim_info)

        source.connect(ConnectionType.CASCADE, Connection(tline1, lambda value: tline1.receive_transmission(TlinePorts.FRONT, value)))
        tline1.connect(
            (ConnectionType.CASCADE, ConnectionType.CASCADE),
            back = Connection(tline2, lambda value: tline2.receive_transmission(TlinePorts.FRONT, value)),
            front = Connection(source, source.receive_transmission)
        )
        tline2.connect(
            (ConnectionType.CASCADE, ConnectionType.CASCADE),
            back = Connection(load, load.receive_transmission),
            front = Connection(tline1, lambda value: tline1.receive_transmission(TlinePorts.BACK, value))
        )

        source_wrapped = ComponentWrapper(source, None, None)
        tline1_wrapped = ComponentWrapper(tline1, np.linspace(0, 50, 60), np.zeros(60))
        tline2_wrapped = ComponentWrapper(tline1, np.linspace(50, 100, 60), np.zeros(60))
        load1_wrapped = ComponentWrapper(load, None, None)

        self.components = [source_wrapped, tline1_wrapped, tline2_wrapped, load1_wrapped]


class ParallelFanOutSim(Simulation):
    """A sample simulation to do testing future simulations should be gathered by a json file"""

    def __init__(self):
        super().__init__(1)

        # source = ACVoltageSource(50, self.sim_info, 5, 0.1, 0)
        source = VoltageSource(50, self.sim_info, 3)
        tline1 = TransmissionLine(100, self.sim_info, 60)
        tline2 = TransmissionLine(100, self.sim_info, 60)
        tline3 = TransmissionLine(100, self.sim_info, 60)

        load1 = ResistiveLoad(100000, self.sim_info)
        load2 = ResistiveLoad(100000, self.sim_info)

        source.connect(ConnectionType.CASCADE, Connection(tline1, lambda value: tline1.receive_transmission(TlinePorts.FRONT, value)))
        tline1.connect(
            (ConnectionType.PARALLEL, ConnectionType.CASCADE),
            [
                Connection(tline2, lambda value: tline2.receive_transmission(TlinePorts.FRONT, value)),
                Connection(tline3, lambda value: tline3.receive_transmission(TlinePorts.FRONT, value)),
            ],
            Connection(source, source.receive_transmission)
        )
        tline2.connect(
            (ConnectionType.CASCADE, ConnectionType.PARALLEL),
            Connection(load1, load1.receive_transmission),
            [
                Connection(tline1, lambda value: tline1.receive_transmission(TlinePorts.BACK, value)),
                Connection(tline3, lambda value: tline3.receive_transmission(TlinePorts.FRONT, value)),
            ],
        )
        tline3.connect(
            (ConnectionType.CASCADE, ConnectionType.PARALLEL),
            Connection(load2, load2.receive_transmission),
            [
                Connection(tline1, lambda value: tline1.receive_transmission(TlinePorts.BACK, value)),
                Connection(tline2, lambda value: tline3.receive_transmission(TlinePorts.FRONT, value)),
            ],
        )

        source_wrapped = ComponentWrapper(source, None, None)
        tline1_wrapped = ComponentWrapper(tline1, np.linspace(0, 60, 60), np.zeros(60))
        tline2_wrapped = ComponentWrapper(tline1, np.concat((np.full(10, 60), np.linspace(60, 110, 50))), np.concat((np.linspace(0, 10, 10), np.full(50, 10))))
        tline3_wrapped = ComponentWrapper(tline1, np.concat((np.full(10, 60), np.linspace(60, 110, 50))), np.concat((np.linspace(0, -10, 10), np.full(50, -10))))
        load1_wrapped = ComponentWrapper(load1, None, None)
        load2_wrapped = ComponentWrapper(load2, None, None)

        self.components = [source_wrapped, tline1_wrapped, tline2_wrapped, tline3_wrapped, load1_wrapped, load2_wrapped]
